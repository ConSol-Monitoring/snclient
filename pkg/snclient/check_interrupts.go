package snclient

import (
	"context"
	"fmt"
	"io"
	"maps"
	"os"
	"slices"
	"strconv"
	"strings"
	"unicode"

	"github.com/consol-monitoring/snclient/pkg/convert"
)

func init() {
	AvailableChecks["check_interrupts"] = CheckEntry{"check_interrupts", NewCheckInterrupt}
}

type CheckInterrupt struct {
	// The CPUs to check interrupts for. Leave it empty to check all CPUs
	cpuFilter       CommaStringList
	interruptFilter CommaStringList
}

func NewCheckInterrupt() CheckHandler {
	return &CheckInterrupt{
		cpuFilter:       CommaStringList{},
		interruptFilter: CommaStringList{},
	}
}

func (checkInterrupt *CheckInterrupt) Build() *CheckData {
	return &CheckData{
		name:        "check_interrupts",
		description: "Check interrupt counts on Linux. This reads and parses the /proc/interrupts file.",
		implemented: Linux,
		result: &CheckResult{
			State: CheckExitOK,
		},
		args: map[string]CheckArgument{
			"cpus": {
				value: &checkInterrupt.cpuFilter,
				description: "CPUs to check interrupts for. Give it as a comma separated list of integers, corresponding to the cpus." +
					" Cpus are indexed starting from zero. Leaving it empty will check all interrupts",
				isFilter: true,
			},
			"interrupts": {
				value: &checkInterrupt.interruptFilter,
				description: "Interrupt acronyms to check filter for." +
					" Give it as a comma separated list of integers corresponding to interrupt ids, or three letter acronymts for named interrupts. E.g 'NMI,154,14,LOC' ",
				isFilter: true,
			},
		},
		detailSyntax: "number: %(interrupt_number) name: (%interrupt_name) cpu: %(cpu) count: %(interrupt_count)",
		okSyntax:     "%(status) - All %(count) interrupts are ok",
		topSyntax:    "%(status) - %(problem_count)/%(count) interrupts , %(problem_list)",
		emptySyntax:  "Failed to find any interrupts matching this filter",
		emptyState:   CheckExitUnknown,
		attributes: []CheckAttribute{
			{name: "interrupt_number", description: "Hardware interrupt lines of the CPU. These are assigned between CPU and other devices by the system firmware, and get an number."},
			{name: "interrupt_name", description: "Named interrupts are generally special events or interrupts generated by the kernel." +
				" These are typically not about the other connected devices to the CPU itself."},
			{name: "cpu", description: "Interrupt the cpu is on. If the interrupt has a single counter, it is assigned to cpu 0."},
			{name: "interrupt_count", description: "The count of the interrupt. Interrupts are almost always counted specifically for each CPU." +
				" Some are counted once per system, and assigned to cpu 0."},
			{name: "interrupt_controller", description: "Mechanism handling the IRQ.IR-IO-APIC interrupts are handled via Advanced Programmable Interrupt. " +
				" These are generally legacy IRQs.IR-PCI-MSI(X) are for Message Signaled Interrupts, generally coming from a PCI device."},
			{name: "interrupt_pci_bdf", description: "The Bus/Device/Function of the device causing the inerrupt." +
				" Generally detectable in PCI interrupts."},
			{name: "interrupt_pin_name_vector", description: "This value contains the interrupt type edge/fasteoi with the physical IRQ pin/line number. " +
				" This is useful when looking at the behaviour of interrupts on the same pin/line."},
			{name: "interrupt_device_and_driver_name", description: "Some interrupts display the logical devices name or the kernel driver that is causing it."},
		},
		exampleDefault: `
Default check does not filter to anything, or has logic to report a warning / critical condition
    OK - All 842 interrupts are ok
    
Check if there is a MCE in core numbers 0,3,7,8
    
    check_interrupts cpus="0,3,7,8" interrupts="MCE" crit="interrupt_count > 0"
    OK - All 4 interrupts are ok |'id: 0 | name: MCE | cpu: 0'=0;;0;0 'id: 0 | name: MCE | cpu: 3'=0;;0;0 'id: 0 | name: MCE | cpu: 7'=0;;0;0 'id: 0 | name: MCE | cpu: 8'=0;;0;0

Same query, but use a numbered interrupt this time.

    check_interrupts cpus="1,2" interrupts="120,121" crit="interrupt_count > 0"
    OK - All 4 interrupts are ok |'id: 120 | name:  | cpu: 1'=0;;0;0 'id: 120 | name:  | cpu: 2'=0;;0;0 'id: 121 | name:  | cpu: 1'=0;;0;0 'id: 121 | name:  | cpu: 2'=0;;0;0

Some interrupts will have a single value for all cores

    check_interrupts interrupt_filter="ERR" crit="interrupt_count > 0"
    OK - All 1 interrupts are ok |'id: 0 | name: ERR | cpu: 0'=0;;0;0

Check interrupts regarding the thunderbolt driver, using the filter on the 'interrrupt_device_and_driver_name' attribute with a string match.
These interrupts are numbered, but it is unclear what these numbers are. One can only match based on the provided driver information. 
    // I dont want thunderbolt controller interrupts to go to cpu0
    check_interrupts cpus="0" filter="interrupt_device_and_driver_name ~ '^thunderbolt' " crit="interrupt_count > 0"
    OK - All 4 interrupts are ok


Check interrupts regarding the NVME device on PCI BDF 00:14.0 , using the filter on the 'interrupt_pci_bdf' attribute. 
Just like above, this interrupt is numbered, so It can be filter with its attribute only. 
The first CPU should get the interrupts with the vector '1-edge' for this device, add a critical condition if it is receiving interrupts with other vectors.
    check_interrupts cpus="0" filter=" interrupt_pci_bdf == '00:14.0' && interrupt_pin_name_and_vector != '1-edge' " crit=" interrupt_count > 0"
    OK - All 1 interrupts are ok
		`,
	}
}

func (checkInterrupt *CheckInterrupt) Check(_ context.Context, snc *Agent, check *CheckData, _ []Argument) (*CheckResult, error) {
	if len(snc.Counter.Keys("cpu")) == 0 {
		return nil, fmt.Errorf("no cpu counter available, make sure CheckSystem / CheckSystemUnix in /modules config is enabled")
	}

	pid, err := readAndParseProcInterrupts()
	if err != nil {
		return nil, fmt.Errorf("error when reading and parsing /proc/interrupts : %s", err.Error())
	}

	for _, interrupt := range pid.interrupts {
		baseEntry := map[string]string{}
		baseEntry["interrupt_name"] = interrupt.interruptName
		baseEntry["interrupt_number"] = strconv.FormatUint(uint64(interrupt.interruptID), 10)
		baseEntry["interrupt_controller"] = interrupt.interruptController
		baseEntry["interrupt_pci_bdf"] = interrupt.interrruptPciBdf
		baseEntry["interrupt_pin_name_vector"] = interrupt.interruptPinNameVector
		baseEntry["interrupt_device_and_driver_name"] = interrupt.interruptDeviceAndDriverName

		if len(checkInterrupt.interruptFilter) > 0 &&
			!slices.Contains(checkInterrupt.interruptFilter, baseEntry["interrupt_name"]) &&
			!slices.Contains(checkInterrupt.interruptFilter, baseEntry["interrupt_number"]) {
			// neither the interrupt_name or the interrupt_number of the filter match this interrupt line
			continue
		}

		if len(interrupt.interruptCountsPerCPU) == 0 {
			// this is a single count interrupt
			entrySingleCount := maps.Clone(baseEntry)
			entrySingleCount["cpu"] = "0"
			entrySingleCount["interrupt_count"] = strconv.FormatUint(interrupt.interruptCountSingle, 10)

			if len(checkInterrupt.cpuFilter) > 0 && !slices.Contains(checkInterrupt.cpuFilter, "0") {
				continue
			}

			check.listData = append(check.listData, entrySingleCount)

			continue
		}

		for cpu, interruptCount := range interrupt.interruptCountsPerCPU {
			entryPerCPU := maps.Clone(baseEntry)
			entryPerCPU["cpu"] = strconv.FormatInt(int64(cpu), 10)
			entryPerCPU["interrupt_count"] = strconv.FormatUint(interruptCount, 10)

			if len(checkInterrupt.cpuFilter) > 0 && !slices.Contains(checkInterrupt.cpuFilter, entryPerCPU["cpu"]) {
				continue
			}

			check.listData = append(check.listData, entryPerCPU)
		}
	}

	// Do not need to add these as metrics
	// needCPU := check.HasThreshold("cpu")
	// needInterruptCount := check.HasThreshold("interrupt_count")
	// needCPU := false
	// needInterruptCount := false
	// for _, data := range check.listData {
	// 	if needCPU {
	// 		check.result.Metrics = append(check.result.Metrics,
	// 			&CheckMetric{
	// 				ThresholdName: "cpu",
	// 				Name:          fmt.Sprintf("number: %s name: %s interrupt_count: %s", data["interrupt_number"], data["interrupt_name"], data["interrupt_count"]),
	// 				Value:         convert.UInt32(data["cpu"]),
	// 				Unit:          "",
	// 				Warning:       check.warnThreshold,
	// 				Critical:      check.critThreshold,
	// 				Min:           &Zero,
	// 			},
	// 		)
	// 	}
	// 	if needInterruptCount {
	// 		check.result.Metrics = append(check.result.Metrics,
	// 			&CheckMetric{
	// 				ThresholdName: "interrupt_count",
	// 				Name:          fmt.Sprintf("id: %s name: %s cpu: %s", data["interrupt_number"], data["interrupt_name"], data["cpu"]),
	// 				Value:         convert.UInt64(data["interrupt_count"]),
	// 				Unit:          "",
	// 				Warning:       check.warnThreshold,
	// 				Critical:      check.critThreshold,
	// 				Min:           &Zero,
	// 			},
	// 		)
	// 	}
	// }

	return check.Finalize()
}

// There is an alternative create for parsing interrupts from Prometheus
// It might be offfering matching/better functionality. It is marked WIP as of November 2025.
// pkg.go.dev/github.com/prometheus/procfs

func parseProcInterrupts(fileContent string) (*ProcInterruptData, error) {
	// First row is listed by CPUs.
	rows := strings.Split(fileContent, "\n")

	if len(rows) == 0 {
		return nil, fmt.Errorf("after splitting the /proc/interrupts file content, there were 0 rows available")
	}

	firstRow := rows[0]

	if firstRow == "" {
		return nil, fmt.Errorf("the first row of the /proc/interrupt seems to be empty")
	}

	// When reading from a file, the last row may be empty
	if rows[len(rows)-1] == "" {
		rows = rows[0 : len(rows)-1]
	}

	cpusStringSliced := strings.Fields(firstRow)

	if !strings.HasSuffix(cpusStringSliced[len(cpusStringSliced)-1], strconv.Itoa(len(cpusStringSliced)-1)) {
		return nil, fmt.Errorf(`the last CPU string on the first row of /proc/interrupts is:%s
		the total whitespace separated fields in the first row of /proc/interrupts is %d ,there is a mismatch`, cpusStringSliced[len(cpusStringSliced)-1], len(cpusStringSliced)-1)
	}

	var data ProcInterruptData
	data.cpuCount = uint64(len(cpusStringSliced))

	// The next rows are about interrupts

	for _, row := range rows[1:] {
		var line ProcInterruptLine

		rowFields := strings.Fields(row)

		if len(rowFields) == 0 {
			return nil, fmt.Errorf("the interrupt row of the /proc/interrupt has no fields when separated by whitespace, something seems wrong: %s", row)
		}

		if err := parseInterruptIdentifier(&rowFields, &line); err != nil {
			return nil, fmt.Errorf("error when parsing interrupt identifier: %w", err)
		}

		if err := parseInterruptCounts(&rowFields, &line, data.cpuCount); err != nil {
			return nil, fmt.Errorf("error when parsing interrupt counts: %w", err)
		}

		// If its an acronym interrupt, the next fields after count are extended name of the acronym
		if line.interruptName != "" {
			// Rejoining them back with a single whitespace might not reconstruct it back to the original, but that is okay for now
			line.interruptAcronymExtended = strings.Join(rowFields, " ")
			data.interrupts = append(data.interrupts, &line)

			continue
		}

		// If its not an acronym, it still has at least three fields
		line.interruptController = rowFields[0]
		line.interruptPinNameVector = rowFields[1]
		line.interruptDeviceAndDriverName = strings.Join(rowFields[2:], " ")

		// Additionally parse the PCI BDF if the interrupt type is MSI(X) . e.g IR-PCI-MSIX-0000:00:14.3
		if strings.Contains(line.interruptController, "PCI-MSI") {
			line.interrruptPciBdf = line.interruptController[len(line.interruptController)-7:]
		}

		data.interrupts = append(data.interrupts, &line)
	}

	return &data, nil
}

func parseInterruptIdentifier(fields *[]string, line *ProcInterruptLine) error {
	// The interrupt identifier is either in form '<number>:' , or 'ABC:' as a three letter acronym
	interruptIdentifierTrimmed := strings.TrimRight((*fields)[0], ":")

	// Try to parse it as a number first, as this case is more common
	parsedInterruptNumber, interruptNumberParseErr := convert.UInt32E(interruptIdentifierTrimmed)
	if interruptNumberParseErr == nil {
		line.interruptID = parsedInterruptNumber

		// increment the fields variable as we parsed the interrupt number
		*fields = (*fields)[1:]

		return nil
	}

	// Try to parse it as an acronym now. The rule to check if it has at least 3 characters, and belongs to a known set of acronyms.

	// I previously thought the acronyms always had three lettters. Some outputs from raspberry pis seem to have longer named interrupts.
	if len(interruptIdentifierTrimmed) < 3 {
		log.Warnf("the interrupt name is thought to be a acronym interrupt: %s , but it has less than three letters", interruptIdentifierTrimmed)
	}

	for _, character := range interruptIdentifierTrimmed {
		if character > unicode.MaxASCII {
			return fmt.Errorf(`the interrupt name is thought to be a acronym interrupt: %s , 
			But it does has a character that is not an ASCII character: %s
			`, interruptIdentifierTrimmed, string(character))
		}

		// I previously thought the acronyms were written in uppercase only. Some outputs from raspberry PIs seem to have mixed case names, and even include numbers
		if !unicode.IsLetter(character) {
			log.Warnf("the interrupt name is thought to be a acronym interrupt: %s , but it does has a non-letter character: %s", interruptIdentifierTrimmed, string(character))
		}
	}

	if !slices.Contains(KnownInterruptAcronyms, interruptIdentifierTrimmed) {
		// Make this a warning instead of a failure
		log.Warnf("the interrupt name is thought to be a acronym interrupt: %s , but it is not in the list of known acronyms", interruptIdentifierTrimmed)
	}

	line.interruptName = interruptIdentifierTrimmed

	*fields = (*fields)[1:]

	return nil
}

func parseInterruptCounts(fields *[]string, line *ProcInterruptLine, cpuCount uint64) error {
	// Some interrupts have no counters at all
	if line.interruptName != "" && slices.Contains(InterruptsWithNoCounters, line.interruptName) {
		return nil
	}

	// If the interrupt has a single counter, it does not have any other fields except value
	if line.interruptName != "" && slices.Contains(InterruptsWithSingleCounters, line.interruptName) {
		parsedNumber, err := convert.UInt64E((*fields)[0])
		if err != nil {
			return fmt.Errorf("could not parse the interrupt counter value: %s to an uint64, which would have been added to the single interrupt count", (*fields)[0])
		}
		line.interruptCountSingle = parsedNumber
		*fields = (*fields)[1:]

		return nil
	}

	// Any other interrupt has a counter per cpu
	for _, field := range (*fields)[0:cpuCount] {
		parsedNumber := convert.UInt64(field)
		line.interruptCountsPerCPU = append(line.interruptCountsPerCPU, parsedNumber)
		*fields = (*fields)[1:]
	}

	return nil
}

func readAndParseProcInterrupts() (*ProcInterruptData, error) {
	file, err := os.Open("/proc/interrupts")
	if err != nil {
		return nil, fmt.Errorf("error when trying to open /proc/interrupts: %w", err)
	}
	defer file.Close()

	fileBytes, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("error when trying to read all of /proc/interrupts: %w", err)
	}
	fileContent := string(fileBytes)

	return parseProcInterrupts(fileContent)
}

var KnownInterruptAcronyms = []string{
	"NMI",
	"LOC",
	"SPU",
	"PMI",
	"IWI",
	"RTR",
	"RES",
	"CAL",
	"TLB",
	"TRM",
	"THR",
	"DFR",
	"MCE",
	"MCP",
	"ERR",
	"MIS",
	"PIN",
	"NPI",
	"PIW",
	"HYP",
	"FIQ",
}

// These interrupts are not counter per CPU
var InterruptsWithSingleCounters = []string{
	"ERR",
	"MIS",
	// Raspberry pi reports this as Err?
	"Err",
}

var InterruptsWithNoCounters = []string{
	"FIQ",
}

type ProcInterruptData struct {
	cpuCount   uint64
	interrupts []*ProcInterruptLine
}

func (pid *ProcInterruptData) findInterruptByID(interruptID uint32) (*ProcInterruptLine, error) {
	for _, line := range pid.interrupts {
		if line.interruptID == interruptID {
			return line, nil
		}
	}

	return nil, fmt.Errorf("could not find an interrupt with the interrupt_id: %d", interruptID)
}

func (pid *ProcInterruptData) findInterruptByName(interruptName string) (*ProcInterruptLine, error) {
	for _, line := range pid.interrupts {
		if line.interruptName == interruptName {
			return line, nil
		}
	}

	return nil, fmt.Errorf("could not find an interrupt with the interrupt_id: %s", interruptName)
}

type ProcInterruptLine struct {
	interruptID                  uint32
	interruptName                string
	interruptCountsPerCPU        []uint64
	interruptCountSingle         uint64
	interruptController          string
	interrruptPciBdf             string
	interruptPinNameVector       string
	interruptDeviceAndDriverName string
	interruptAcronymExtended     string
}
