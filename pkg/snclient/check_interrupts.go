package snclient

import (
	"context"
	"fmt"
	"io"
	"os"
	"slices"
	"strconv"
	"strings"
	"unicode"
)

func init() {
	AvailableChecks["check_interrupts"] = CheckEntry{"check_interrupts", NewCheckInterrupt}
}

type CheckInterrupt struct {
	// The CPUs to check interrupts for. Leave it empty to check all CPUs
	cpu_list []uint32
}

func NewCheckInterrupt() CheckHandler {
	return &CheckInterrupt{
		cpu_list: make([]uint32, 0),
	}
}

func (checkInterrupt *CheckInterrupt) Build() *CheckData {
	return &CheckData{
		name:        "check_interrupt",
		description: "Checks the interrupts on CPUs",
		implemented: Linux,
		result: &CheckResult{
			State: CheckExitOK,
		},
		args: map[string]CheckArgument{
			"cpu_list": {
				value:       &checkInterrupt.cpu_list,
				description: "CPUs to check interrupts for. Leaving it empty will check all interrupts",
			},
		},
		emptySyntax: "check_interrupt failed to find any inerrupt.",
		attributes: []CheckAttribute{
			{name: "interrupt_number", description: "Hardware interrupt lines of the CPU. These are assigned between CPU and other devices by the system firmware, and get an number."},
			{name: "interrupt_name", description: "Named interrupts are generally special events or interrupts generated by the kernel. These are typically not about the other connected devices to the CPU itself."},
			{name: "interrupt_controller", description: "Mechanism handling the IRQ.\nIR-IO-APIC interrupts are handled via Advanced Programmable Interrupt. These are generally legacy IRQs.\n IR-PCI-MSI(X) are for Message Signaled Interrupts, generally coming from a PCI device.\n"},
			{name: "interrupt_pci_bdf", description: "The Bus/Device/Function of the device causing the inerrupt. Generally detectable in PCI interrupts."},
			{name: "interrupt_pin_name_vector", description: "This value contains the interrupt type edge/fasteoi with the physical IRQ pin/line number. This is useful when looking at the behaviour of interrupts on the same pin/line."},
			{name: "interrupt_device_and_driver_name", description: "Some interrupts display the logical devices name or the kernel driver that is causing it."},
		},
	}
}

func (checkInterrupt *CheckInterrupt) Check(ctx context.Context, snc *Agent, check *CheckData, _ []Argument) (*CheckResult, error) {

	if len(snc.Counter.Keys("cpu")) == 0 {
		return nil, fmt.Errorf("no cpu counter available, make sure CheckSystem / CheckSystemUnix in /modules config is enabled")
	}

}

// Alternative create, possibly offfering matching/better functionality. It is marked WIP as of November 2025.
// pkg.go.dev/github.com/prometheus/procfs

func ReadAndParseProcInterrupts() (*ProcInterruptData, error) {
	file, err := os.Open("/proc/interrupts")
	if err != nil {
		return nil, fmt.Errorf("Error when trying to open /proc/interrupts:\n%v", err)
	}
	defer file.Close()

	file_content, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("Error when trying to read all of /proc/interrupts:\n%v", err)
	}

	// First row is listed by CPUs.

	rows := strings.Split(string(file_content), "\n")

	if len(rows) == 0 {
		return nil, fmt.Errorf("After splitting the /proc/interrupts file content, there were 0 rows available")
	}

	first_row := rows[0]
	cpus_string_slices := strings.Fields(first_row)

	if strings.HasSuffix(cpus_string_slices[len(cpus_string_slices)-1], strconv.Itoa(len(cpus_string_slices)-1)) == false {
		return nil, fmt.Errorf("The last CPU string on the first row of /proc/interrupts is:%s\nThe total whitespace seperated fields in the first row of /proc/interrupts is %d.\nThere is a mismatch", cpus_string_slices[len(cpus_string_slices)-1], len(cpus_string_slices)-1)
	}

	// if len(cpus_string_slices) != snc.Counter.Keys("cpu") {
	// 	return nil, fmt.Errorf("Discovered CPU count by the snclient is %d\nThe first line of /proc/interrupts listed %d CPUs.\n There is a mismatch")
	// }

	var data ProcInterruptData
	data.cpu_count = (uint32)(len(cpus_string_slices))

	// The next rows are about interrupts

	for _, row := range rows[1:] {
		var line ProcInterruptLine

		row_fields := strings.Fields(row)

		// This is either a number
		interrupt_identifier := row_fields[0]

		// The interrupt identifier is either in form '<number>:' , or 'ABC:' as a three letter acronym
		interrupt_identifier_trimmed := strings.TrimRight(interrupt_identifier, ":")

		// Try to parse it as a number first, as this case is more common
		var interrupt_name string
		parsed_number, err := strconv.ParseUint(interrupt_identifier_trimmed, 10, 32)
		if err == nil {
			line.interrupt_id = uint32(parsed_number)
			goto interrupt_identifier_parse_complete
		}

		// Try to parse it as an acronym now. The rule to check if it has 3 characters, all uppercase, and belongs to a known set of acronyms.

		if len(interrupt_identifier_trimmed) != 3 {
			return nil, fmt.Errorf("The interrupt name is thought to be a acronym interrupt: %v\nBut it does not have three letters.")
		}

		for _, c := range interrupt_identifier_trimmed {
			if c > unicode.MaxASCII {
				return nil, fmt.Errorf("The interrupt name is thought to be a acronym interrupt: %v\nBut it does has a character that is not an ASCII character: %v", c)
			}
			if !unicode.IsUpper(c) {
				return nil, fmt.Errorf("The interrupt name is thought to be a acronym interrupt: %v\nBut it does has a character that is not uppercase: %v", c)
			}
		}

		if !slices.Contains(KNOWN_INTERRUPT_ACRONYMS, interrupt_identifier_trimmed) {
			return nil, fmt.Errorf("The interrupt name is thought to be a acronym interrupt: %v\nBut it is not in the list of known acronyms", interrupt_identifier_trimmed)
		}

		line.interrupt_name = interrupt_identifier_trimmed

	interrupt_identifier_parse_complete:

		// row_fields now start from interrupt counts
		row_fields = row_fields[1:]

		// If the interrupt has a single counter, it does not have any other fields except value
		if line.interrupt_name != "" && slices.Contains(INTERRUPTS_WITH_SINGLE_COUNTERS, interrupt_name) {
			parsed_number, err := strconv.ParseUint(row_fields[0], 10, 64)
			if err != nil {
				return nil, fmt.Errorf("Could not parse the interrupt counter value to an uint64, which would have been added to the interrupt counters array per CPUs: %v", row_fields[0])
			}
			line.interrupt_count_single = parsed_number
			if err != nil {
				return nil, fmt.Errorf("The interrupt name is thought to be a acronym interrupt: %v\nBut it is not in the list of known acronyms: %v", c)
			}
			row_fields = row_fields[1:]
			continue
		}

		// Any other interrupt has ine field per cpu
		for _, field := range row_fields[0:data.cpu_count] {
			parsed_number, err := strconv.ParseUint(field, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("Could not parse the interrupt counter value to an uint64, which would have been added to the interrupt counters array per CPUs: %v", field)
			}
			line.interrupt_counts_per_cpu = append(line.interrupt_counts_per_cpu, parsed_number)
		}

		// row_fields now start after interrupt counts
		row_fields = row_fields[data.cpu_count:]

		// If its an acronym interrupt, the next fields after count are extended name of the acronym
		if interrupt_name != "" {
			line.interrupt_acronym_extended = strings.Join(row_fields, " ")
			continue
		}

		// If its not an acronym, it still has three fields

		line.interrupt_controller = row_fields[0]
		line.interrupt_pin_name_vector = row_fields[1]
		line.interrupt_device_and_driver_name = strings.Join(row_fields[2:], " ")

		// Additionally parse the PCI BDF if the interrupt type is MSI(X)
		if strings.Contains(line.interrupt_controller, "PCI-MSI") {
			interrupt_controller_split := strings.Split(line.interrupt_controller, ":")
			line.interrupt_pci_bdf = interrupt_controller_split[len(interrupt_controller_split)-1]
		}

	}

	return &data, nil
}

var KNOWN_INTERRUPT_ACRONYMS = []string{
	"NMI",
	"LOC",
	"SPU",
	"PMU",
	"IWI",
	"RTR",
	"RES",
	"CAL",
	"TLB",
	"TRM",
	"THR",
	"DFR",
	"MCE",
	"MCP",
	"ERR",
	"MIS",
	"PIN",
	"NPI",
	"PIW",
}

// These interrupts are not counter per CPU
var INTERRUPTS_WITH_SINGLE_COUNTERS = []string{
	"ERR",
	"MIS",
}

type ProcInterruptData struct {
	cpu_count  uint32
	interrupts []ProcInterruptLine
}

type ProcInterruptLine struct {
	interrupt_id                     uint32
	interrupt_name                   string
	interrupt_counts_per_cpu         []uint64
	interrupt_count_single           uint64
	interrupt_controller             string
	interrupt_pci_bdf                string
	interrupt_pin_name_vector        string
	interrupt_device_and_driver_name string
	interrupt_acronym_extended       string
}
