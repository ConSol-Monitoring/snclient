package snclient

import (
	"context"
	"fmt"
	"io"
	"maps"
	"os"
	"slices"
	"strconv"
	"strings"
	"unicode"

	"github.com/consol-monitoring/snclient/pkg/convert"
)

func init() {
	AvailableChecks["check_interrupts"] = CheckEntry{"check_interrupts", NewCheckInterrupt}
}

type CheckInterrupt struct {
	// The CPUs to check interrupts for. Leave it empty to check all CPUs
	cpu_filter       CommaStringList
	interrupt_filter CommaStringList
}

func NewCheckInterrupt() CheckHandler {
	return &CheckInterrupt{
		cpu_filter:       CommaStringList{},
		interrupt_filter: CommaStringList{},
	}
}

func (checkInterrupt *CheckInterrupt) Build() *CheckData {
	return &CheckData{
		name:        "check_interrupt",
		description: "Checks the interrupts on CPUs",
		implemented: Linux,
		result: &CheckResult{
			State: CheckExitOK,
		},
		args: map[string]CheckArgument{
			"cpu_filter": {
				value:       &checkInterrupt.cpu_filter,
				description: "CPUs to check interrupts for. Give it as a comma seperated list of integers, corresponding to the cpus. Cpus are indexed starting from zero. Leaving it empty will check all interrupts",
			},
			"interrupt_filter": {
				value:       &checkInterrupt.interrupt_filter,
				description: "Interrupt acronyms to check filter for. Give it as a comma seperated list of integers corresponding to interrupt ids, or three letter acronymts for named interrupts. E.g 'NMI,154,14,LOC' ",
			},
		},
		detailSyntax: "%(interrupt_number)|(%interrupt_name)",
		okSyntax:     "%(status) - All %(count) interrupts are ok",
		topSyntax:    "%(status) - %(problem_count)/%(count) interrupts , %(problem_list)",
		emptySyntax:  "Failed to find any interrupts matching this filter",
		emptyState:   CheckExitUnknown,
		attributes: []CheckAttribute{
			{name: "interrupt_number", description: "Hardware interrupt lines of the CPU. These are assigned between CPU and other devices by the system firmware, and get an number."},
			{name: "cpu", description: "Interrupt the cpu is on. If the interrupt has a single counter, it is assigned to cpu 0."},
			{name: "interrupt_count", description: "The count of the interrupt. Interrupts are almost always counted specifically for each CPU. Some are counted once per system, and assigned to cpu 0."},
			{name: "interrupt_name", description: "Named interrupts are generally special events or interrupts generated by the kernel. These are typically not about the other connected devices to the CPU itself."},
			{name: "interrupt_controller", description: "Mechanism handling the IRQ.IR-IO-APIC interrupts are handled via Advanced Programmable Interrupt. These are generally legacy IRQs.IR-PCI-MSI(X) are for Message Signaled Interrupts, generally coming from a PCI device."},
			{name: "interrupt_pci_bdf", description: "The Bus/Device/Function of the device causing the inerrupt. Generally detectable in PCI interrupts."},
			{name: "interrupt_pin_name_vector", description: "This value contains the interrupt type edge/fasteoi with the physical IRQ pin/line number. This is useful when looking at the behaviour of interrupts on the same pin/line."},
			{name: "interrupt_device_and_driver_name", description: "Some interrupts display the logical devices name or the kernel driver that is causing it."},
		},
		exampleDefault: `
Alter if there is a MCE in core numbers 0,3,7,8
		check_interrupts cpu_list="0,3,7,8" interrupt_filter="MCE" crit="interrupt_count > 0"
		`,
	}
}

func (checkInterrupt *CheckInterrupt) Check(ctx context.Context, snc *Agent, check *CheckData, _ []Argument) (*CheckResult, error) {

	if len(snc.Counter.Keys("cpu")) == 0 {
		return nil, fmt.Errorf("no cpu counter available, make sure CheckSystem / CheckSystemUnix in /modules config is enabled")
	}

	pid, err := ReadAndParseProcInterrupts()
	if err != nil {
		return nil, fmt.Errorf("error when reading and parsing /proc/interrupts : %s", err.Error())
	}

	var cpu_filter []string
	if cpu_filter_argument, ok := check.args["cpu_filter"]; ok {
		if cpu_filter_csl_ptr, ok := cpu_filter_argument.value.(*CommaStringList); ok {
			csl_value := *cpu_filter_csl_ptr
			cpu_filter = []string(csl_value)
		} else {
			return nil, fmt.Errorf("unexpected type for cpu_filter_argument.value , expected *CommaStringList")
		}
	}

	var interrupt_filter []string
	if interrupt_filter_argument, ok := check.args["interrupt_filter"]; ok {
		if interrupt_filter_csl_ptr, ok := interrupt_filter_argument.value.(*CommaStringList); ok {
			csl_value := *interrupt_filter_csl_ptr
			interrupt_filter = []string(csl_value)
		} else {
			return nil, fmt.Errorf("unexpected type for interrupt_filter_argument.value , expected *CommaStringList")
		}
	}

	for _, interrupt := range pid.interrupts {

		entry := map[string]string{}
		entry["interrupt_name"] = interrupt.interrupt_name
		entry["interrupt_number"] = strconv.FormatUint(uint64(interrupt.interrupt_id), 10)
		entry["interrupt_controller"] = interrupt.interrupt_controller
		entry["interrupt_pci_bdf"] = interrupt.interrupt_pci_bdf
		entry["interrupt_pin_name_vector"] = interrupt.interrupt_pin_name_vector
		entry["interrupt_device_and_driver_name"] = interrupt.interrupt_device_and_driver_name

		if len(interrupt_filter) > 0 && !slices.Contains(interrupt_filter, entry["interrupt_name"]) && !slices.Contains(interrupt_filter, entry["interrupt_number"]) {
			// neither the interrupt_name or the interrupt_number of the filter match this interrupt line
			continue
		}

		if len(interrupt.interrupt_counts_per_cpu) == 0 {
			// this is a single count interrupt
			entry["cpu"] = "0"
			entry["interrupt_count"] = strconv.FormatUint(uint64(interrupt.interrupt_count_single), 10)

			if len(cpu_filter) > 0 && !slices.Contains(cpu_filter, "0") {
				continue
			}

			check.listData = append(check.listData, entry)
			continue
		}

		for cpu, interrupt_count := range interrupt.interrupt_counts_per_cpu {
			entry := maps.Clone(entry)
			entry["cpu"] = strconv.FormatUint(uint64(cpu), 10)
			entry["interrupt_count"] = strconv.FormatUint(uint64(interrupt_count), 10)

			if len(cpu_filter) > 0 && !slices.Contains(cpu_filter, entry["cpu"]) {
				continue
			}

			check.listData = append(check.listData, entry)
		}

	}

	needInterruptCount := check.HasThreshold("interrupt_count")
	for _, data := range check.listData {
		if needInterruptCount {
			check.result.Metrics = append(check.result.Metrics,
				&CheckMetric{
					ThresholdName: "interrupt_count",
					Name:          fmt.Sprintf("id: %s ; name: %s ; cpu: %s ; interrupt_count: %s", data["interrupt_number"], data["interrupt_name"], data["cpu"], data["interrupt_count"]),
					Value:         convert.UInt64(data["interrupt_count"]),
					Unit:          "",
					Warning:       check.warnThreshold,
					Critical:      check.critThreshold,
					Min:           &Zero,
				},
			)
		}
	}

	return check.Finalize()

}

// Alternative create, possibly offfering matching/better functionality. It is marked WIP as of November 2025.
// pkg.go.dev/github.com/prometheus/procfs

func ParseProcInterrupts(file_content string) (*ProcInterruptData, error) {
	// First row is listed by CPUs.

	rows := strings.Split(string(file_content), "\n")

	if len(rows) == 0 {
		return nil, fmt.Errorf("after splitting the /proc/interrupts file content, there were 0 rows available")
	}

	first_row := rows[0]

	if first_row == "" {
		return nil, fmt.Errorf("the first row of the /proc/interrupt seems to be empty")
	}

	// When reading from a file, the last row is empty
	if rows[len(rows)-1] == "" {
		rows = rows[0 : len(rows)-1]
	}

	cpus_string_slices := strings.Fields(first_row)

	if !strings.HasSuffix(cpus_string_slices[len(cpus_string_slices)-1], strconv.Itoa(len(cpus_string_slices)-1)) {
		return nil, fmt.Errorf("the last CPU string on the first row of /proc/interrupts is:%s , the total whitespace seperated fields in the first row of /proc/interrupts is %d ,there is a mismatch", cpus_string_slices[len(cpus_string_slices)-1], len(cpus_string_slices)-1)
	}

	// if len(cpus_string_slices) != snc.Counter.Keys("cpu") {
	// 	return nil, fmt.Errorf("Discovered CPU count by the snclient is %d\nThe first line of /proc/interrupts listed %d CPUs.\n There is a mismatch")
	// }

	var data ProcInterruptData
	data.cpu_count = (uint32)(len(cpus_string_slices))

	// The next rows are about interrupts

	for _, row := range rows[1:] {
		var line ProcInterruptLine

		row_fields := strings.Fields(row)

		if len(row_fields) == 0 {
			return nil, fmt.Errorf("the interrupt row of the /proc/interrupt has no fields when seperated by whitespace, something seems wrong: %s", row)
		}

		// This is either a number
		interrupt_identifier := row_fields[0]

		// The interrupt identifier is either in form '<number>:' , or 'ABC:' as a three letter acronym
		interrupt_identifier_trimmed := strings.TrimRight(interrupt_identifier, ":")

		// Try to parse it as a number first, as this case is more common
		parsed_interrupt_number, parse_interrupt_number_err := strconv.ParseUint(interrupt_identifier_trimmed, 10, 32)
		if parse_interrupt_number_err == nil {
			line.interrupt_id = uint32(parsed_interrupt_number)
			goto interrupt_identifier_parse_complete
		}

		// Try to parse it as an acronym now. The rule to check if it has 3 characters, all uppercase, and belongs to a known set of acronyms.

		if len(interrupt_identifier_trimmed) != 3 {
			return nil, fmt.Errorf("the interrupt name is thought to be a acronym interrupt: %s , but it does not have three letters", interrupt_identifier_trimmed)
		}

		for _, c := range interrupt_identifier_trimmed {
			if c > unicode.MaxASCII {
				return nil, fmt.Errorf("the interrupt name is thought to be a acronym interrupt: %s , but it does has a character that is not an ASCII character: %v", interrupt_identifier_trimmed, c)
			}
			if !unicode.IsUpper(c) {
				return nil, fmt.Errorf("the interrupt name is thought to be a acronym interrupt: %s , but it does has a character that is not uppercase: %v", interrupt_identifier_trimmed, c)
			}
		}

		if !slices.Contains(KNOWN_INTERRUPT_ACRONYMS, interrupt_identifier_trimmed) {
			return nil, fmt.Errorf("the interrupt name is thought to be a acronym interrupt: %s , but it is not in the list of known acronyms", interrupt_identifier_trimmed)
		}

		line.interrupt_name = interrupt_identifier_trimmed

	interrupt_identifier_parse_complete:

		// row_fields now start from interrupt counts
		row_fields = row_fields[1:]

		// If the interrupt has a single counter, it does not have any other fields except value
		if line.interrupt_name != "" && slices.Contains(INTERRUPTS_WITH_SINGLE_COUNTERS, line.interrupt_name) {
			parsed_number, err := strconv.ParseUint(row_fields[0], 10, 64)
			if err != nil {
				return nil, fmt.Errorf("could not parse the interrupt counter value: %s to an uint64, which would have been added to the single interrupt count", row_fields[0])
			}
			line.interrupt_count_single = parsed_number
			data.interrupts = append(data.interrupts, line)
			// the line for these types of interrupts ends after the single count.
			continue
		}

		// Any other interrupt has ine field per cpu
		for _, field := range row_fields[0:data.cpu_count] {
			parsed_number, err := strconv.ParseUint(field, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("could not parse the interrupt counter value: %s to an uint64, which would have been added to the interrupt counters array for CPUs", field)
			}
			line.interrupt_counts_per_cpu = append(line.interrupt_counts_per_cpu, parsed_number)
		}

		// row_fields now start after interrupt counts
		row_fields = row_fields[data.cpu_count:]

		// If its an acronym interrupt, the next fields after count are extended name of the acronym
		if line.interrupt_name != "" {
			// Rejoining them back with a single whitespace might not reconstruct it back to the original
			line.interrupt_acronym_extended = strings.Join(row_fields, " ")
			data.interrupts = append(data.interrupts, line)
			continue
		}

		// If its not an acronym, it still has three fields

		line.interrupt_controller = row_fields[0]
		line.interrupt_pin_name_vector = row_fields[1]
		line.interrupt_device_and_driver_name = strings.Join(row_fields[2:], " ")

		// Additionally parse the PCI BDF if the interrupt type is MSI(X) . e.g IR-PCI-MSIX-0000:00:14.3
		if strings.Contains(line.interrupt_controller, "PCI-MSI") {
			line.interrupt_pci_bdf = line.interrupt_controller[len(line.interrupt_controller)-7:]
		}

		data.interrupts = append(data.interrupts, line)
	}

	return &data, nil
}

func ReadAndParseProcInterrupts() (*ProcInterruptData, error) {
	file, err := os.Open("/proc/interrupts")
	if err != nil {
		return nil, fmt.Errorf("error when trying to open /proc/interrupts: %s", err)
	}
	defer file.Close()

	file_bytes, err := io.ReadAll(file)
	if err != nil {
		return nil, fmt.Errorf("error when trying to read all of /proc/interrupts: %s", err)
	}
	file_content := string(file_bytes)

	return ParseProcInterrupts(file_content)
}

var KNOWN_INTERRUPT_ACRONYMS = []string{
	"NMI",
	"LOC",
	"SPU",
	"PMI",
	"IWI",
	"RTR",
	"RES",
	"CAL",
	"TLB",
	"TRM",
	"THR",
	"DFR",
	"MCE",
	"MCP",
	"ERR",
	"MIS",
	"PIN",
	"NPI",
	"PIW",
	"HYP",
}

// These interrupts are not counter per CPU
var INTERRUPTS_WITH_SINGLE_COUNTERS = []string{
	"ERR",
	"MIS",
}

type ProcInterruptData struct {
	cpu_count  uint32
	interrupts []ProcInterruptLine
}

func (pid *ProcInterruptData) FindInterruptById(interrupt_id uint32) (*ProcInterruptLine, error) {
	for _, line := range pid.interrupts {
		if line.interrupt_id == interrupt_id {
			return &line, nil
		}
	}

	return nil, fmt.Errorf("could not find an interrupt with the interrupt_id: %d", interrupt_id)
}

func (pid *ProcInterruptData) FindInterruptByName(interrupt_name string) (*ProcInterruptLine, error) {
	for _, line := range pid.interrupts {
		if line.interrupt_name == interrupt_name {
			return &line, nil
		}
	}

	return nil, fmt.Errorf("could not find an interrupt with the interrupt_id: %s", interrupt_name)
}

type ProcInterruptLine struct {
	interrupt_id                     uint32
	interrupt_name                   string
	interrupt_counts_per_cpu         []uint64
	interrupt_count_single           uint64
	interrupt_controller             string
	interrupt_pci_bdf                string
	interrupt_pin_name_vector        string
	interrupt_device_and_driver_name string
	interrupt_acronym_extended       string
}
